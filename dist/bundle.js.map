{"mappings":"2HAEO,MAAMA,EAAe,CAC1BC,KAAM,8CACHC,KAAG,EAACC,EAAEA,EAACC,KAAEA,EAAIC,QAAEA,KACV,MAANF,IAAeE,EAAQD,IAAS,CAAC,GAAI,IAAM,KAAME,SAASF,IACzDG,IAAE,KACLC,MAAO,EAAC,EAAI,IAGDC,EAAiB,CAC5B,CACER,KAAM,UACJC,KAAI,EAACC,EAAEA,EAACO,KAAEA,KAAiB,MAANP,GAAuB,MAATO,EACnCH,IAAG,IACLC,MAAO,CAAC,EAAG,IAEb,CACEN,KAAM,EAACC,EAAEA,EAACC,KAAEA,KAAiB,MAAND,GAAuB,MAATC,EACnCG,IAAG,KAIII,EAAc,CACzBV,KAAM,gCACLC,KAAK,EAACC,EAAEA,EAACE,QAAEA,EAAOD,KAAEA,EAAIM,KAAEA,KACnB,MAANP,GAAcE,EAAQD,IAASC,EAAQK,GACxCH,IAAI,KACLC,MAAO,EAAC,EAAI,IAGDI,EAAiB,CAC5B,CACEX,KAAM,+BACLC,KAAK,EAACC,EAAEA,EAACC,KAAEA,EAAIM,KAAEA,EAAIL,QAAEA,KAChB,MAANF,GAAcE,EAAQD,IAASC,EAAQK,GACxCH,IAAI,IACLC,MAAO,EAAC,EAAI,IAEd,CACEP,KAAM,qBACFC,KAAE,EAACC,EAAEA,EAACO,KAAEA,KAAiB,MAANP,GAAc,CAAC,IAAK,IAAM,KAAKG,SAASI,GAC7DH,IAAK,IACLC,MAAO,CAAC,EAAG,KCxCJK,EAAgB,CAC3B,CACEC,KAAM,KACNC,GAAI,KACJC,KAAM,CACJ,IAAC,IACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,QACA,WACA,UACA,QACA,OACA,QACA,SACA,UAEHC,MAAO,CACLjB,KACGS,EACHE,KACGC,EACH,CACEX,KAAM,qCACHC,KAAG,EAACC,EAAEA,EAACC,KAAEA,KACJ,MAAND,GAAc,CAAC,IAAM,KAAMG,SAASF,GACnCG,IAAE,GACLC,MAAO,EAAC,EAAI,IAEd,CACEP,KAAM,2DACLC,KAAK,EAACC,EAAEA,EAACe,EAAEA,KAAc,MAANf,KAAgBe,EAAEC,MAAK,+BACrBZ,IAAjB,OAIX,CACEO,KAAM,KACNC,GAAI,KACJC,KAAM,CACJ,IAAC,IACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,QACA,OACA,QACA,SACA,WAGL,CACEF,KAAM,KACNC,GAAI,aACJC,KAAM,CACJ,IAAC,IACA,QACA,QACA,QACA,QACA,QACA,QACC,IAAD,IACC,IAAD,IACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACC,IAAD,IACA,SACA,QACA,QACC,IAAD,IACC,IAAD,IACA,QACC,IAAD,IACC,IAAD,KACA,SACA,IAAI,IACH,IAAK,IACH,IAAH,OCrIMI,EAAgB,CAC3B,CACEN,KAAM,KACNC,GAAI,KACJC,KAAM,CACJ,IAAC,IACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,QACA,WACA,UACA,cACA,OACA,QACA,OACA,QACA,SACA,UAEHC,MAAO,CACLjB,KACGS,EACHE,KACGC,EACH,CACEX,KAAM,qCACHC,KAAG,EAACC,EAAEA,EAACC,KAAEA,KAAiB,MAAND,GAAc,CAAC,IAAM,KAAMG,SAASF,GACxDG,IAAE,GACLC,MAAO,EAAC,EAAI,IAEd,CACEP,KAAM,4BACDC,KAAC,EAACC,EAAEA,EAACC,KAAEA,KAAiB,MAAND,GAAc,CAAC,IAAM,IAAM,IAAM,KAAMG,SAASF,GAClEG,IAAA,IACLC,MAAO,EAAC,EAAI,IAEd,CACEP,KAAM,qCACAC,KAAA,EAACC,EAAEA,EAACC,KAAEA,EAAIM,KAAEA,EAAIW,UAAEA,KAChB,MAANlB,GACC,KAAM,KAAMG,SAASF,IACb,MAAPM,GACgB,KAAjBW,EAAS,GACZd,IAAK,IACLC,MAAO,EAAC,EAAI,IAEd,CACEP,KAAM,0DACIC,KAAJ,EAACC,EAAEA,EAACe,EAAEA,KAAc,MAANf,GAAoB,cAANe,EACxBX,IAAL,KACLC,MAAO,CAAC,EAAG,IAEb,CACEP,KAAM,sDACEC,KAAF,EAACC,EAAEA,EAACe,EAAEA,KAAc,MAANf,GAAoB,YAANe,EAC1BX,IAAH,KACLC,MAAO,CAAC,EAAG,IAEb,CACEP,KAAM,yDACLC,KAAK,EAACC,EAAEA,EAACe,EAAEA,KAAc,MAANf,GAAc,CAAC,UAAkB,UAAgBG,SAASY,GAChEX,IAAT,KAEP,CACEN,KAAM,2DACLC,KAAK,EAACC,EAAEA,EAACe,EAAEA,KACJ,MAANf,KAAgBe,EAAEC,MAAK,+BACHZ,IAAjB,OAIX,CACEO,KAAM,KACNC,GAAI,KACJC,KAAM,CACJ,IAAC,IACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,UACA,OACA,QACA,OACA,QACA,SACA,WAGL,CACEF,KAAM,KACNC,GAAI,aACJC,KAAM,CACJ,IAAC,IACA,QACA,QACA,QACA,QACA,QACA,QACC,IAAD,IACC,IAAD,IACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,QACA,QACC,IAAD,IACC,IAAD,KACE,IAAF,IACC,IAAD,IACA,QACC,IAAD,IACC,IAAD,KACA,SACA,IAAI,IACH,IAAK,IACH,IAAH,OCzKMM,EAAgB,CAC3B,CACER,KAAM,KACNC,GAAI,KACJC,KAAM,CACJ,IAAC,IACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,QACA,QACA,QACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,QACA,WACA,UACA,cACA,OACA,SACA,SACA,IAAI,GACL,IAAO,GACL,IAAI,IAERC,MAAO,CACL,CACEhB,KAAM,4CACJC,KAAI,EAACC,EAAEA,EAACC,KAAEA,EAAIC,QAAEA,KAAoB,MAANF,IAAeE,EAAQD,IAAS,CAAC,GAAI,KAAME,SAASF,IAClFG,IAAG,KACLC,MAAO,EAAC,EAAI,OAEXC,EACHE,EACA,CACEV,KAAM,+BACJC,KAAI,EAACC,EAAEA,EAACC,KAAEA,KAAiB,MAAND,GAAuB,MAATC,EACnCG,IAAG,GACLC,MAAO,EAAC,EAAI,OAEXI,EACH,CACEX,KAAM,2DACLC,KAAK,EAACC,EAACA,EAACe,EAAEA,KAAa,MAANf,KAAgBe,EAAEC,MAAK,+BACnBZ,IAAjB,OAKX,CACEO,KAAM,KACNC,GAAI,KACJC,KAAM,CACJ,IAAC,IACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,SACA,SACA,SACA,WACA,OACA,SACA,SACA,IAAI,GACL,IAAO,GACL,IAAI,IAERC,MAAO,CACL,CACEhB,KAAM,uCACLC,KAAK,EAACC,EAAEA,EAACC,KAAEA,KAAiB,MAAND,GAAuB,KAATC,EACpCG,IAAI,MAEP,CACEN,KAAM,uCACLC,KAAK,EAACC,EAAEA,EAACC,KAAEA,KAAiB,MAAND,GAAuB,KAATC,EACpCG,IAAI,MAEP,CACEN,KAAM,sCACLC,KAAK,EAACC,EAAEA,EAACC,KAAEA,KAAiB,MAAND,GAAuB,KAATC,EACpCG,IAAI,KAEP,CACEN,KAAM,uCACLC,KAAK,EAACC,EAAEA,EAACC,KAAEA,KAAiB,MAAND,GAAuB,KAATC,EACpCG,IAAI,MAEP,CACEN,KAAM,uCACLC,KAAK,EAACC,EAAEA,EAACC,KAAEA,KAAiB,MAAND,GAAuB,KAATC,EACpCG,IAAI,MAEP,CACEN,KAAM,YACJC,KAAI,EAACC,EAAEA,EAACC,KAAEA,KAAiB,MAAND,GAAuB,MAATC,EACnCG,IAAG,KACLC,MAAO,EAAC,EAAI,MAIlB,CACEM,KAAM,KACNC,GAAI,aACJC,KAA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","sources":["src/langs/_shared.ts","src/langs/belarusian.ts","src/langs/russian.ts","src/langs/ukrainian.ts","src/helpers.ts","src/transkribator.ts","src/index.ts"],"sourcesContent":["import { Rule } from \"../types\"\n\nexport const jeRule: Rule = {\n  desc: \"е -> je am Wortanfang, nach ь / ъ / Vokalen\",\n  cond: ({ c, prev, isVowel }) =>\n    c === \"е\" && (isVowel(prev) || [\"\", \"ь\", \"ъ\"].includes(prev)),\n  val: \"je\",\n  range: [-1, 1],\n}\n\nexport const xRules: Rule[] = [\n  {\n    desc: \"кс -> x\",\n    cond: ({ c, next }) => c === \"к\" && next === \"с\",\n    val: \"x\",\n    range: [0, 2],\n  },\n  {\n    cond: ({ c, prev }) => c === \"с\" && prev === \"к\",\n    val: \"\",\n  },\n]\n\nexport const sRule: Rule = {\n  desc: \"с -> ss zwischen zwei Vokalen\",\n  cond: ({ c, isVowel, prev, next }) =>\n    c === \"с\" && isVowel(prev) && isVowel(next),\n  val: \"ss\",\n  range: [-1, 2],\n}\n\nexport const jRules: Rule[] = [\n  {\n    desc: \"й -> j zwischen zwei Vokalen\",\n    cond: ({ c, prev, next, isVowel }) =>\n      c === \"й\" && isVowel(prev) && isVowel(next),\n    val: \"j\",\n    range: [-1, 2],\n  },\n  {\n    desc: \"ьи -> ji, ьо -> jo\",\n    cond: ({ c, next }) => c === \"ь\" && [\"i\", \"и\", \"о\"].includes(next),\n    val: \"j\",\n    range: [0, 2],\n  },\n]\n","import { LangDef } from \"../types\"\nimport { jeRule, jRules, sRule, xRules } from \"./_shared\"\n\nexport const be: LangDef[] = [\n  {\n    from: \"be\",\n    to: \"de\",\n    dict: {\n      а: \"a\",\n      б: \"b\",\n      в: \"w\",\n      г: \"h\",\n      д: \"d\",\n      е: \"e\",\n      ё: \"jo\",\n      ж: \"sh\",\n      з: \"s\",\n      і: \"i\",\n      й: \"i\",\n      к: \"k\",\n      л: \"l\",\n      м: \"m\",\n      н: \"n\",\n      о: \"o\",\n      п: \"p\",\n      р: \"r\",\n      с: \"s\",\n      т: \"t\",\n      у: \"u\",\n      ў: \"u\",\n      ф: \"f\",\n      х: \"ch\",\n      ц: \"z\",\n      ч: \"tsch\",\n      ш: \"sch\",\n      ы: \"y\",\n      ь: \"\",\n      э: \"e\",\n      ю: \"ju\",\n      я: \"ja\",\n    },\n    rules: [\n      jeRule,\n      ...xRules,\n      sRule,\n      ...jRules,\n      {\n        desc: \"й nicht wiedergegeben nach ы und і\",\n        cond: ({ c, prev }) =>\n          c === \"й\" && [\"ы\", \"і\"].includes(prev),\n        val: \"\",\n        range: [-1, 1],\n      },\n      {\n        desc: \"V statt W am Wortbeginn (gebräuchliche Namensschreibung)\",\n        cond: ({ c, w }) => c === \"в\" && !!w.match(/^(валянцін|віктар|веранік)/i),\n        val: \"v\",\n      },\n    ],\n  },\n  {\n    from: \"be\",\n    to: \"en\",\n    dict: {\n      а: \"a\",\n      б: \"b\",\n      в: \"v\",\n      г: \"h\",\n      д: \"d\",\n      е: \"e\",\n      ё: \"yo\",\n      ж: \"zh\",\n      з: \"z\",\n      і: \"i\",\n      й: \"i\",\n      к: \"k\",\n      л: \"l\",\n      м: \"m\",\n      н: \"n\",\n      о: \"o\",\n      п: \"p\",\n      р: \"r\",\n      с: \"s\",\n      т: \"t\",\n      у: \"u\",\n      ў: \"u\",\n      ф: \"f\",\n      х: \"kh\",\n      ц: \"ts\",\n      ч: \"ch\",\n      ш: \"sh\",\n      ы: \"y\",\n      ь: \"\",\n      э: \"e\",\n      ю: \"yu\",\n      я: \"ya\",\n    },\n  },\n  {\n    from: \"be\",\n    to: \"scientific\",\n    dict: {\n      а: \"a\",\n      б: \"b\",\n      в: \"v\",\n      г: \"h\",\n      д: \"d\",\n      е: \"e\",\n      ё: \"ё\",\n      ж: \"ž\",\n      з: \"z\",\n      і: \"i\",\n      й: \"j\",\n      к: \"k\",\n      л: \"l\",\n      м: \"m\",\n      н: \"n\",\n      о: \"o\",\n      п: \"p\",\n      р: \"r\",\n      с: \"s\",\n      т: \"t\",\n      у: \"u\",\n      ў: \"ŭ\",\n      ф: \"f\",\n      х: \"ch\",\n      ц: \"c\",\n      ч: \"č\",\n      ш: \"š\",\n      ы: \"y\",\n      ь: \"ʹ\",\n      э: \"ė\",\n      ю: \"ju\",\n      я: \"ja\",\n      \"'\": \"’\",\n      \"’\": \"’\",\n      ʼ: \"’\",\n    },\n  },\n]\n","import { LangDef } from \"../types\"\nimport { jeRule, jRules, sRule, xRules } from \"./_shared\"\n\nexport const ru: LangDef[] = [\n  {\n    from: \"ru\",\n    to: \"de\",\n    dict: {\n      а: \"a\",\n      б: \"b\",\n      в: \"w\",\n      г: \"g\",\n      д: \"d\",\n      е: \"e\",\n      ё: \"jo\",\n      ж: \"sh\",\n      з: \"s\",\n      и: \"i\",\n      й: \"i\",\n      к: \"k\",\n      л: \"l\",\n      м: \"m\",\n      н: \"n\",\n      о: \"o\",\n      п: \"p\",\n      р: \"r\",\n      с: \"s\",\n      т: \"t\",\n      у: \"u\",\n      ф: \"f\",\n      х: \"ch\",\n      ц: \"z\",\n      ч: \"tsch\",\n      ш: \"sch\",\n      щ: \"schtsch\",\n      ъ: \"\",\n      ы: \"y\",\n      ь: \"\",\n      э: \"e\",\n      ю: \"ju\",\n      я: \"ja\",\n    },\n    rules: [\n      jeRule,\n      ...xRules,\n      sRule,\n      ...jRules,\n      {\n        desc: \"й nicht wiedergegeben nach ы und и\",\n        cond: ({ c, prev }) => c === \"й\" && [\"ы\", \"и\"].includes(prev),\n        val: \"\",\n        range: [-1, 1],\n      },\n      {\n        desc: \"ё -> o nach ж / ч / ш / щ\",\n        cond: ({ c, prev }) => c === \"ё\" && [\"ж\", \"ч\", \"ш\", \"щ\"].includes(prev),\n        val: \"o\",\n        range: [-1, 1],\n      },\n      {\n        desc: \"-ого/-его -> -owo/-ewo am Wortende\",\n        cond: ({ c, prev, next, charAtPos }) =>\n          c === \"г\" &&\n          [\"е\", \"о\"].includes(prev) &&\n          next === \"о\" &&\n          charAtPos(+2) === \"\",\n        val: \"w\",\n        range: [-1, 2],\n      },\n      {\n        desc: \"Александр -> Alexander (gebräuchliche Namensschreibung)\",\n        cond: ({ c, w }) => c === \"д\" && w === \"александр\",\n        val: \"de\",\n        range: [0, 2],\n      },\n      {\n        desc: \"Дмитрий -> Dimitri (gebräuchliche Namensschreibung)\",\n        cond: ({ c, w }) => c === \"д\" && w === \"дмитрий\",\n        val: \"di\",\n        range: [0, 2],\n      },\n      {\n        desc: \"j statt i am Wortende (gebräuchliche Namensschreibung)\",\n        cond: ({ c, w }) => c === \"й\" && [\"алексей\", \"сергей\"].includes(w),\n        val: \"j\",\n      },\n      {\n        desc: \"V statt W am Wortbeginn (gebräuchliche Namensschreibung)\",\n        cond: ({ c, w }) =>\n          c === \"в\" && !!w.match(/^(валентин|виктор|вероник)/i),\n        val: \"v\",\n      },\n    ],\n  },\n  {\n    from: \"ru\",\n    to: \"en\",\n    dict: {\n      а: \"a\",\n      б: \"b\",\n      в: \"v\",\n      г: \"g\",\n      д: \"d\",\n      е: \"e\",\n      ё: \"yo\",\n      ж: \"zh\",\n      з: \"z\",\n      и: \"i\",\n      й: \"i\",\n      к: \"k\",\n      л: \"l\",\n      м: \"m\",\n      н: \"n\",\n      о: \"o\",\n      п: \"p\",\n      р: \"r\",\n      с: \"s\",\n      т: \"t\",\n      у: \"u\",\n      ф: \"f\",\n      х: \"kh\",\n      ц: \"ts\",\n      ч: \"ch\",\n      ш: \"sh\",\n      щ: \"sch\",\n      ъ: \"\",\n      ы: \"i\",\n      ь: \"\",\n      э: \"e\",\n      ю: \"yu\",\n      я: \"ya\",\n    },\n  },\n  {\n    from: \"ru\",\n    to: \"scientific\",\n    dict: {\n      а: \"a\",\n      б: \"b\",\n      в: \"v\",\n      г: \"g\",\n      д: \"d\",\n      е: \"e\",\n      ё: \"ё\",\n      ж: \"ž\",\n      з: \"z\",\n      и: \"i\",\n      й: \"j\",\n      к: \"k\",\n      л: \"l\",\n      м: \"m\",\n      н: \"n\",\n      о: \"o\",\n      п: \"p\",\n      р: \"r\",\n      с: \"s\",\n      т: \"t\",\n      у: \"u\",\n      ф: \"f\",\n      х: \"ch\",\n      ц: \"c\",\n      ч: \"č\",\n      ш: \"š\",\n      щ: \"šč\",\n      ъ: \"ʺ\",\n      ы: \"y\",\n      ь: \"ʹ\",\n      э: \"ė\",\n      ю: \"ju\",\n      я: \"ja\",\n      \"'\": \"’\",\n      \"’\": \"’\",\n      ʼ: \"’\",\n    },\n  },\n]\n","import { LangDef } from \"../types\"\nimport { jRules, sRule, xRules } from \"./_shared\"\n\nexport const uk: LangDef[] = [\n  {\n    from: \"uk\",\n    to: \"de\",\n    dict: {\n      а: \"a\",\n      б: \"b\",\n      в: \"w\",\n      г: \"h\",\n      ґ: \"g\",\n      д: \"d\",\n      е: \"e\",\n      є: \"e\",\n      ж: \"sh\",\n      з: \"s\",\n      и: \"y\",\n      і: \"i\",\n      ї: \"ji\",\n      й: \"i\",\n      к: \"k\",\n      л: \"l\",\n      м: \"m\",\n      н: \"n\",\n      о: \"o\",\n      п: \"p\",\n      р: \"r\",\n      с: \"s\",\n      т: \"t\",\n      у: \"u\",\n      ф: \"f\",\n      х: \"ch\",\n      ц: \"z\",\n      ч: \"tsch\",\n      ш: \"sch\",\n      щ: \"schtsch\",\n      ь: \"\",\n      ю: \"ju\",\n      я: \"ja\",\n      \"'\": \"\",\n      \"’\": \"\",\n      \"ʼ\": \"\",\n    },\n    rules: [\n      {\n        desc: \"є -> je am Wortanfang, nach ь und Vokalen\",\n        cond: ({ c, prev, isVowel }) => c === \"є\" && (isVowel(prev) || [\"\", \"ь\"].includes(prev)),\n        val: \"je\",\n        range: [-1, 1]\n      },\n      ...xRules,\n      sRule,\n      {\n        desc: \"й nicht wiedergegeben nach и\",\n        cond: ({ c, prev }) => c === \"й\" && prev === \"и\",\n        val: \"\",\n        range: [-1, 1]\n      },\n      ...jRules,\n      {\n        desc: \"V statt W am Wortbeginn (gebräuchliche Namensschreibung)\",\n        cond: ({c, w}) => c === \"в\" && !!w.match(/^(валентин|віктор|веронік)/i),\n        val: \"v\"\n      }\n    ],\n  },\n\n  {\n    from: \"uk\",\n    to: \"en\",\n    dict: {\n      а: \"a\",\n      б: \"b\",\n      в: \"v\",\n      г: \"h\",\n      ґ: \"g\",\n      д: \"d\",\n      е: \"e\",\n      є: \"ie\",\n      ж: \"zh\",\n      з: \"z\",\n      и: \"y\",\n      і: \"i\",\n      ї: \"i\",\n      й: \"i\",\n      к: \"k\",\n      л: \"l\",\n      м: \"m\",\n      н: \"n\",\n      о: \"o\",\n      п: \"p\",\n      р: \"r\",\n      с: \"s\",\n      т: \"t\",\n      у: \"u\",\n      ф: \"f\",\n      х: \"kh\",\n      ц: \"ts\",\n      ч: \"ch\",\n      ш: \"sh\",\n      щ: \"shch\",\n      ь: \"\",\n      ю: \"iu\",\n      я: \"ia\",\n      \"'\": \"\",\n      \"’\": \"\",\n      \"ʼ\": \"\",\n    },\n    rules: [\n      {\n        desc: \"є -> ye at the beginning of the word\",\n        cond: ({ c, prev }) => c === \"є\" && prev === \"\",\n        val: \"ye\"\n      },\n      {\n        desc: \"ї -> yi at the beginning of the word\",\n        cond: ({ c, prev }) => c === \"ї\" && prev === \"\",\n        val: \"yi\"\n      },\n      {\n        desc: \"й -> y at the beginning of the word\",\n        cond: ({ c, prev }) => c === \"й\" && prev === \"\",\n        val: \"y\"\n      },\n      {\n        desc: \"ю -> yu at the beginning of the word\",\n        cond: ({ c, prev }) => c === \"ю\" && prev === \"\",\n        val: \"yu\"\n      },\n      {\n        desc: \"я -> ya at the beginning of the word\",\n        cond: ({ c, prev }) => c === \"я\" && prev === \"\",\n        val: \"ya\"\n      },\n      {\n        desc: \"зг -> zgh\",\n        cond: ({ c, prev }) => c === \"г\" && prev === \"з\",\n        val: \"gh\",\n        range: [-1, 1]\n      }\n    ]\n  },\n  {\n    from: \"uk\",\n    to: \"scientific\",\n    dict: {\n      а: \"a\",\n      б: \"b\",\n      в: \"v\",\n      г: \"h\",\n      ґ: \"g\",\n      д: \"d\",\n      е: \"e\",\n      є: \"je\",\n      ж: \"ž\",\n      з: \"z\",\n      и: \"y\",\n      і: \"i\",\n      ї: \"ji\",\n      й: \"j\",\n      к: \"k\",\n      л: \"l\",\n      м: \"m\",\n      н: \"n\",\n      о: \"o\",\n      п: \"p\",\n      р: \"r\",\n      с: \"s\",\n      т: \"t\",\n      у: \"u\",\n      ф: \"f\",\n      х: \"ch\",\n      ц: \"c\",\n      ч: \"č\",\n      ш: \"š\",\n      щ: \"šč\",\n      ь: \"ʹ\",\n      ю: \"ju\",\n      я: \"ja\",\n      \"'\": \"’\",\n      \"’\": \"’\",\n      \"ʼ\": \"’\",\n    },\n  },\n]\n","const VOWELS = [\"а\", \"е\", \"є\", \"ё\", \"и\", \"і\", \"ї\", \"о\", \"у\", \"ы\", \"ю\", \"э\", \"я\"]\n\nexport function isVowel(char: string) {\n  return VOWELS.includes(char)\n}\n\nexport function matchCase(char = \"\", compareChar = \"\", word = \"\") {\n  return isUpperCase(word)\n    ? char.toUpperCase()\n    : isUpperCase(compareChar)\n    ? capitalizeFirst(char)\n    : char\n}\n\nfunction isUpperCase(str: string) {\n  return str === str.toUpperCase()\n}\n\nfunction capitalizeFirst(str: string) {\n  const [first, ...rest] = str\n  if (!first) return \"\"\n  return [first.toUpperCase(), ...rest].join(\"\")\n}\n","import { isVowel, matchCase } from \"./helpers\"\nimport { LangDef, AppliedRule, LetterRange } from \"./types\"\n\nexport class Transkribator {\n  def: LangDef\n  alphabet: string[]\n  appliedRules: AppliedRule[]\n  debug: boolean\n  constructor(def: LangDef, debug = false) {\n    this.def = def\n    this.alphabet = Object.keys(this.def.dict)\n    this.appliedRules = []\n    this.debug = debug\n  }\n\n  transcribe(input = \"\") {\n    input = input.normalize()\n    const words = input.split(\" \")\n    let output = input\n    for (let word of words) {\n      word = this.clean(word)\n      output = output.replace(word, this.transcribeWord(word))\n    }\n    const { appliedRules, def } = this\n    return { output, appliedRules, from: def.from, to: def.to }\n  }\n\n  transcribeWord(word = \"\") {\n    const chars = word.trim().split(\"\")\n    return chars.reduce((result, char, pos, chars) => {\n      const newChar =\n        this.getRuleBasedChar(char, pos, chars, word) ??\n        this.getDictChar(char) ??\n        char\n      return result + matchCase(newChar, char, word)\n    }, \"\")\n  }\n\n  getRuleBasedChar(char: string, pos: number, chars: string[], word: string) {\n    const charAtPos = (delta: number) => this.normalize(chars[pos + delta])\n    const args = {\n      c: this.normalize(char),\n      w: this.normalize(word),\n      char,\n      charAtPos,\n      prev: charAtPos(-1),\n      next: charAtPos(+1),\n      isVowel,\n    }\n    if (this.debug) console.log(args)\n    for (const rule of this.def.rules || []) {\n      const { desc: description, cond, val, range = [0, 1] } = rule\n      if (cond(args)) {\n        const affectedLetters: LetterRange = [pos + range[0], pos + range[1]]\n        const appliedRule = { description, word, affectedLetters }\n        if (description) this.appliedRules.push(appliedRule)\n        return val\n      }\n    }\n  }\n\n  getDictChar(char: string) {\n    return this.def.dict[char.toLowerCase()]\n  }\n\n  normalize(charOrStr = \"\") {\n    const inAlphabet = new RegExp(`[${this.alphabet.join()}]`, \"i\")\n    return charOrStr.match(inAlphabet) ? charOrStr.toLowerCase() : \"\"\n  }\n\n  clean(str: string): string {\n    const punctationAtEnd = new RegExp(`([^${this.alphabet.join()}]+)$`, \"ig\")\n    return str.replace(punctationAtEnd, \"\")\n  }\n}\n","import { be } from \"./langs/belarusian\"\nimport { ru } from \"./langs/russian\"\nimport { uk } from \"./langs/ukrainian\"\nimport { Transkribator } from \"./transkribator\"\nimport { Options, UserOptions, Result } from \"./types\"\n\nconst DEFS = [...be, ...ru, ...uk]\nconst DEFAULT_OPTIONS: Options = { from: \"ru\", to: \"en\", showDetails: false }\n\nexport function transcribe(input = \"\", _options: UserOptions = {}) {\n  const options = { ...DEFAULT_OPTIONS, ..._options }\n  const { from, to, showDetails, debug } = options\n  const langDef = DEFS.find((d) => d.from === from && d.to === to)\n  if (!langDef) {\n    console.error(`No language module ${from}-${to} found`)\n    const result: Result = { output: input, appliedRules: [], from, to }\n    return showDetails ? result : result.output\n  }\n  const result: Result = new Transkribator(langDef, !!debug).transcribe(input)\n  return showDetails ? result : result.output\n}\n"],"names":["$f0eadbbb5ec6822f$export$df8169a6258d50c7","desc","cond","c","prev","isVowel","includes","val","range","$f0eadbbb5ec6822f$export$d827822e4858809f","next","$f0eadbbb5ec6822f$export$dde5208fce538b35","$f0eadbbb5ec6822f$export$ebc19a8c8453432e","$d0ff8f09c5a3f477$export$51b138e5a065c2bb","from","to","dict","rules","w","match","$43afad44a193bf7c$export$cf48009033a0126b","charAtPos","$d6ea688fdad8f553$export$312745a8a3013c00","$dcc79b8af9b61d4b$var$VOWELS","$dcc79b8af9b61d4b$export$8111e1eeaad1861d","char","$dcc79b8af9b61d4b$export$539e7ee389f27fc6","compareChar","word","$dcc79b8af9b61d4b$var$isUpperCase","toUpperCase","str","first","rest","join","$dcc79b8af9b61d4b$var$capitalizeFirst","$1429d22315ea2189$export$5af97e1f35ce3ad3","constructor","def","debug","this","alphabet","Object","keys","appliedRules","transcribe","input","words","normalize","split","output","clean","replace","transcribeWord","trim","reduce","result","pos","chars","getRuleBasedChar","getDictChar","delta","args","console","log","rule","description","appliedRule","push","toLowerCase","charOrStr","inAlphabet","RegExp","punctationAtEnd","$eb7869949b641a40$var$DEFS","$eb7869949b641a40$var$DEFAULT_OPTIONS","showDetails","$eb7869949b641a40$export$6479b296c537a758","_options","options","langDef","find","d","error"],"version":3,"file":"bundle.js.map"}